diff --git a/tensorboard/defs/protos.bzl b/tensorboard/defs/protos.bzl
index e1dbe485d..b7c42d460 100644
--- a/tensorboard/defs/protos.bzl
+++ b/tensorboard/defs/protos.bzl
@@ -12,79 +12,108 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.

-load("@com_google_protobuf//:protobuf.bzl", "proto_gen")
+load("@com_github_grpc_grpc//bazel:python_rules.bzl", "py_grpc_library")
+load("@com_google_protobuf//bazel:cc_proto_library.bzl", "cc_proto_library")
+load("@com_google_protobuf//bazel:py_proto_library.bzl", "py_proto_library")
 load("@rules_python//python:py_library.bzl", "py_library")

-# TODO(#6185): try to reduce the complexity in this rule.
+load(
+    "@xla//xla/tsl/platform/default:build_config.bzl",
+    "well_known_proto_libs",
+)
+
+load(
+    "@xla//xla/tsl/platform:build_config.bzl",
+    "tf_proto_library",
+)
+
 def tb_proto_library(
         name,
-        srcs = None,
+        srcs = [],
         deps = [],
-        visibility = None,
-        testonly = None,
         has_services = False,
-        # The `exports` arg is unused here, but required internally for compatibility.
-        exports = []):
-    outs_proto = _PyOuts(srcs, grpc = False)
-    outs_grpc = _PyOuts(srcs, grpc = True) if has_services else []
-    outs_all = outs_proto + outs_grpc
-
-    # Dependencies we need to operate protoc (the protobuf compiler), including
-    # protoc itself, the intermediate generated proto output from the runtime
-    # bundled with protoc (to provide proto types used during the protoc code
-    # generation process itself), and the grpc plugin to protoc used for gRPC
-    # service generation.
-    protoc = "@com_google_protobuf//:protoc"
-    protoc_runtime_genproto = "@com_google_protobuf//:protobuf_python_genproto"
-    grpc_python_plugin = "//external:grpc_python_plugin"
+        visibility = None,
+        **kwargs):

-    # Python generated code relies on a Python protobuf runtime to be present.
-    # The runtime version must be compatible (typically, >=) with the protoc
-    # that was used to generate the code. There is a runtime provided along
-    # with protoc as part of our build-time dependency on protobuf (the target
-    # is "@com_google_protobuf//:protobuf_python"), but we deliberately don't
-    # use it, because our tests may need to use a protobuf runtime that is
-    # higher than our protoc version in order to be compatible with generated
-    # protobuf code used by our dependencies (namely, TensorFlow). Instead, we
-    # rely on picking up protobuf ambiently from the virtual environment, the
-    # same way that it will behave when released in our pip package.
-    runtime = "//tensorboard:expect_protobuf_installed"
+    testonly = 0
+    tags = []
+    compatible_with = None
+    exports = []
+    native.filegroup(
+        name = name + "_proto_srcs",
+        srcs = srcs + deps,
+        testonly = testonly,
+        visibility = visibility,
+    )

-    proto_gen(
-        name = name + "_genproto",
+    if name.endswith("_proto"):
+        name_sans_proto = name[:-6]
+    else:
+        name_sans_proto = name
+    native.proto_library(
+        name = name,
         srcs = srcs,
-        deps = [s + "_genproto" for s in deps] + [protoc_runtime_genproto],
-        includes = [],
-        protoc = protoc,
-        gen_py = True,
-        outs = outs_all,
-        visibility = ["//visibility:public"],
-        plugin = grpc_python_plugin if has_services else None,
-        plugin_language = "grpc",
+        deps = deps + well_known_proto_libs(),
+        exports = exports,
+        compatible_with = compatible_with,
+        visibility = visibility,
+        testonly = testonly,
+        tags = tags,
     )

-    py_deps = [s + "_py_pb2" for s in deps] + [runtime]
-    py_library(
-        name = name + "_py_pb2",
-        srcs = outs_proto,
-        imports = [],
-        srcs_version = "PY3",
-        deps = py_deps,
+    cc_proto_name = name + "_cc"
+    cc_proto_library(
+        name = cc_proto_name,
+        testonly = testonly,
+        compatible_with = compatible_with,
+        visibility = visibility,
+        deps = [":{}".format(name)],
+    )
+
+    native.alias(
+        name = name + "_cc_impl",
+        testonly = testonly,
+        actual = name + "_cc",
+        compatible_with = compatible_with,
+        visibility = visibility,
+    )
+
+    native.alias(
+        name = name + "_cc_headers_only",
         testonly = testonly,
+        actual = name + "_cc",
+        compatible_with = compatible_with,
         visibility = visibility,
     )
+
+    py_deps = []
+    py_proto_name = name + "_py_pb2"
+    py_deps.append(":{}".format(py_proto_name))
+    py_proto_library(
+        name = py_proto_name,
+        testonly = testonly,
+        compatible_with = compatible_with,
+        visibility = visibility,
+        deps = [":{}".format(name)],
+    )
+
     if has_services:
-        py_library(
-            name = name + "_py_pb2_grpc",
-            srcs = outs_grpc,
-            imports = [],
-            srcs_version = "PY3",
-            deps = [name + "_py_pb2"] + py_deps,
+        py_grpc_name = name + "_py_grpc_proto"
+        py_deps.append(":{}".format(py_grpc_name))
+        py_grpc_library(
+            name = name + "_py_grpc_proto",
+            srcs = [":{}".format(name)],
+            deps = [":{}".format(py_proto_name)],
             testonly = testonly,
+            compatible_with = compatible_with,
             visibility = visibility,
         )

-def _PyOuts(srcs, grpc):
-    # Adapted from @com_google_protobuf//:protobuf.bzl.
-    ext = "_pb2.py" if not grpc else "_pb2_grpc.py"
-    return [s[:-len(".proto")] + ext for s in srcs]
+    py_library(
+        name = name + "_py",
+        srcs = py_deps,
+        deps = py_deps,
+        testonly = testonly,
+        compatible_with = compatible_with,
+        visibility = visibility,
+    )
